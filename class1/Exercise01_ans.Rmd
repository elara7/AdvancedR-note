---
title: "Exercise01_ans"
author: "wangzx"
date: "2017年3月18日"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

benchmark based on Intel® Xeon® Processor E3-1230 v3 @ 3.30 GHz, 16.0 GB RAM, Windows 10 pro 1607

# time transform function

```{r}
timetrans <- function(x){
  as.POSIXct(paste0(paste(as.character(Sys.Date()),x), ":00"))
}
```

# load data

```{r}
ds<-data.frame(id=seq(10,80,by=10),
               anest=c("baker","baker",rep("dow",6)),
               start=c("08:00","09:00","09:00","08:00","10:00","12:30","13:30","18:00"),
               end=c("11:00","13:00","15:30","13:30","11:30","13:30","14:30","19:00"),
               stringsAsFactors = F)
```

# convert data

```{r}
d <- ds[ds$anest == "dow",]
d$start <- timetrans(d$start)
d$end <- timetrans(d$end)
```

# solution a

```{r}
solutiona <- function(data){
  #data <- data[data$anest == "dow",]
  #data$start <- timetrans(data$start)
  #data$end <- timetrans(data$end)
  n <- nrow(data)
  # 生成两两比较数据
  ini <- matrix(NA,nrow = n*(n-1)/2, ncol = 3)
  k=1
  for(i in 1:(n-1)){
    for(j in (i+1):n){
      ini[k,] <- c(data[c(i,j),"id"] ,max(data[c(i,j),"start"]) < min(data[c(i,j),"end"]))
      k = k + 1
    }
  }
  # 转换为矩阵
  #ini <- matrix(ini,ncol = 3, byrow = T)
  colnames(ini) <- c('id1','id2','cross')
  
  #初始化
  outini <- ini[which(ini[,'cross']==1),c('id1','id2')]
  outnew <- outini
  #进入循环搜索
  while(!is.null(outnew)){
    out <- outnew # 更新结果
    outnew <- NULL # 初始化中间变量
    wide <- ncol(out) #设定最后一列索引
    for(i in 1:nrow(out)){
      ans <- ini[which(ini[,'id1']==out[,wide][i] & ini[,'cross']==1),'id2',drop=F] #搜索最后一列对应下一次结果
      if(nrow(ans)!=0){
        #temp <-cbind(matrix(rep(out[i,,drop=F],nrow(ans)), byrow = T,nrow = nrow(ans)), ans) #合并
        outnew <- rbind(outnew,cbind(matrix(rep(out[i,,drop=F],nrow(ans)), byrow = T,nrow = nrow(ans)), ans))
      }
    }
  }
  colnames(out) <- NULL
  return(list(times=dim(out)[2],res=out))
}
solutiona(d)
microbenchmark::microbenchmark(solutiona(d))

#$times
#[1] 3
#
#$res
#     [,1] [,2] [,3]
#[1,]   30   40   50
#[2,]   30   40   60
#
#> microbenchmark::microbenchmark(solutiona(d))
#Unit: milliseconds
#         expr      min       lq     mean   median       uq      max neval
# solutiona(d) 2.129874 2.246352 2.404954 2.312133 2.453959 3.902696   100
```

```{r}
library(compiler)
solutionacompiled3 <- cmpfun(solutiona, options = list(optimize=3))
microbenchmark::microbenchmark(solutionacompiled3(d))
```


# solution a(cpp)

```{r}
library(Rcpp)
cppFunction('
  IntegerMatrix solutionacpp(DataFrame x){
    IntegerVector id = x["id"];
    IntegerVector start = x["start"];
    IntegerVector end = x["end"];
    int n = id.size();
    IntegerMatrix ini(n*(n-1)/2,3);
    int k = 0;
    int startmax = 0;
    int endmin = 0;
    for(int i = 0; i < (n-1); i++){
      for(int j = (i+1); j < n; j++){
        ini(k, 0) = id[i];
        ini(k, 1) = id[j];
        if(start[i] < start[j])
        {
          startmax = start[j];
        }
        else
        {
          startmax = start[i];
        }
        if(end[i] < end[j])
        {
          endmin = end[i];
        }
        else
        {
          endmin = end[j];
        }
        if(startmax < endmin)
        {
          ini(k, 2) = 1;
        }
        else
        {
          ini(k, 2) = 0;
        }
        k++;
      }
    }
    return(ini);
  }'
)
solutionacpp(d)
microbenchmark::microbenchmark(solutionacpp(d))
```


# solution 1

```{r}
# check overlap
check <- function(index, data){
  res <- index[max(data[index,]$start) < min(data[index,]$end)]
  if(length(res)!=0){
    return(res)
  }
}

# generate combn
index <- function(n){
  ind <- NULL
  for( k in 2:n){
    ind <- c(ind, combn(n, k, simplify = F))
  }
  return(ind)
}

# find overlap
findoverlap <- function(data){
  n <- nrow(data)
  Filter(Negate(is.null), lapply(index(n),function(x){check(x,data)}))
}

solution1 <- function(data){
  res <- findoverlap(data)
  l <- sapply(res,length)
  postion <- which(l == max(l))
  return(list(times = max(l), id = lapply(postion, function(x){d[res[[x]],"id"]})))
}

solution1(d)
microbenchmark::microbenchmark(solution1(d))



#$times
#[1] 3
#
#$id
#$id[[1]]
#[1] 30 40 50
#
#$id[[2]]
#[1] 30 40 60
#
#
#Unit: milliseconds
#         expr      min       lq     mean   median       uq      max neval
# solution1(d) 13.46007 14.14292 15.90477 14.48878 15.09091 109.7427   100
```

# solution 2

```{r}
solution2 <- function(data){
  # find interval
  interval <- sort(unique((c(data$start,data$end))))
  range <- data.frame(row.names = data$id)
  
  for (i in 1:nrow(range)){
    for (j in 1:(length(interval)-1)){
      if(max(c(data$start[i],interval[j]))<min(c(data$end[i],interval[j+1]))){
        range[i,j] <- 1
        }else{
          range[i,j] <- 0
        }
    }
  }
  
  max_time <- max(colSums(range))
  res <- range[,which(colSums(range[,])==max_time)]
  return(list(times = max_time, id = lapply(res, function(x){rownames(res)[x==1]})))
}

solution2(d)
microbenchmark::microbenchmark(solution2(d))



#$times
#[1] 3
#
#$id
#$id$V3
#[1] "30" "40" "50"
#
#$id$V5
#[1] "30" "40" "60"
#
#
#Unit: milliseconds
#         expr      min       lq     mean   median       uq      max neval
# solution2(d) 11.65708 12.29794 14.36177 12.69931 13.27159 152.0636   100
```

# solution 3

伪代码：

n = 数据行数

for k n->2：
    index <- $C_n^k$ 所有组合组成的list
    对 index 中的每一个项：
        if max（数据中index对应的行的start值）<min（数据中index对应的列的end值） then
           取出数据的id值，添加到res后
        else 返回NULL
    将res的NULL值清空
    if res不为空 then 返回res的长度和id
    

```{r}
solution3 <- function(data){
  n <- nrow(data)
  for( k in n:2){
    index <- combn(n, k, simplify = F)
    res <- Filter(Negate(is.null), lapply(index, function(x){if(max(data[x,]$start) < min(data[x,]$end)){data[x,"id"]}}))
    if(length(res)!=0){
      return(list(times = length(res[[1]]), id = res))
    }
  }
}
solution3(d)
microbenchmark::microbenchmark(solution3(d))



#$times
#[1] 3
#
#$id
#$id[[1]]
#[1] 30 40 50
#
#$id[[2]]
#[1] 30 40 60
#
#
#Unit: milliseconds
#         expr      min       lq     mean  median       uq      max neval
# solution3(d) 9.783489 10.40024 11.20711 10.7884 11.73344 15.58466   100
```




# solution 4
```{r}
solution4 <- function(data){
  n <- nrow(data)
  Filter(Negate(is.null), lapply(lapply(n:2, function(x){combn(n,x)}), function(x){Filter(Negate(is.null), apply(x ,2, function(x){if(max(data[x,]$start) < min(data[x,]$end)){data[x,"id"]}}))}))
}
solution4(d)
microbenchmark::microbenchmark(solution4(d))



#[[1]]
#[[1]][[1]]
#[1] 30 40 50
#
#[[1]][[2]]
#[1] 30 40 60
#
#
#[[2]]
#[[2]][[1]]
#[1] 30 40
#
#[[2]][[2]]
#[1] 30 50
#
#[[2]][[3]]
#[1] 30 60
#
#[[2]][[4]]
#[1] 30 70
#
#[[2]][[5]]
#[1] 40 50
#
#[[2]][[6]]
#[1] 40 60
#
#
#Unit: milliseconds
#         expr     min       lq     mean   median      uq     max neval
# solution4(d) 13.4778 14.23032 15.46657 14.58302 15.2049 45.3407   100
```

# 罗老师的心路历程

```{r}
#创建提取子矩阵  方法一
a<-c(1,2,5)
sm<-outer(a,a,FUN = "paste",sep=",")
sm<-c(sm)
sm<-paste0(sm,collapse=",")
sm<-strsplit(sm,",")
sm<-unlist(sm)
sm<-as.numeric(sm)
sm<-matrix(sm,ncol = 2,byrow = T)
#创建提取子矩阵   方法二
a<-c(1,2,5)
n<-length(a)
x1<-rep(a,n)
x2<-rep(a,each=n)
sm<-as.matrix(data.frame(x1,x2))
#创建提取子矩阵  方法三
sm<-as.matrix(data.frame(expand.grid(x = c(1,2,5), y = c(1,2,5))))
```

